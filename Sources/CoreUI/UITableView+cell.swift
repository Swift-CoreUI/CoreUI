import UIKit

public extension UITableView {

    /**
     Registers cell for given type in this TableView using autogenerated reuseIdentifier
     */
    func register<Cell>(_ cellType: Cell.Type) where Cell: UITableViewCell {
        register(cellType, forCellReuseIdentifier: String(describing: cellType))
    }

    /**
     Returns TableView cell for given type using autogenerated reuseIdentifier.
     If cell with this reuseIdentifier is not registered in this tableView - registers it automatically
     Returned cell already has given type, so no casting will be necessary
     Usage:
     ```
     // somewhere in cellForRowAtIndexPath
     let cell = tableView.cell(withType: MyCustomTableViewCell.self)
     cell.someFieldExistingInMyCustomCell = 100

     // or (that's where default for cell type will stand in)
     let cell2 = tableView.cell() as MyCustomTableViewCell
     ```
     */
    func cell<Cell>(withType cellType: Cell.Type = Cell.self, withIdentifier reuseIdentifier: String? = nil) -> Cell
    where Cell: UITableViewCell {
        let reuseIdentifier = reuseIdentifier ?? String(describing: cellType)

        var cell = dequeueReusableCell(withIdentifier: reuseIdentifier)

        if cell == nil {
            register(cellType, forCellReuseIdentifier: reuseIdentifier)
            cell = dequeueReusableCell(withIdentifier: reuseIdentifier)
        }

        return cell as! Cell // swiftlint:disable:this force_cast
    }

    /**
     Empty cell with minimal height for any tableview, supports reuse.
     Usage: ```
     // somewhere in cellForRowAtIndexPath
     guard let item = itemForIndexPath(indexPath) else {
        return tableView.emptyCell
     }
     ```
     */
    var emptyCell: UITableViewCell { cell(withType: EmptyTableViewCell.self) }

    /**
     Registers header of footer view for given type in this TableView using autogenerated reuseIdentifier
     */
    func registerHeaderFooterView<View>(_ viewType: View.Type) where View: UITableViewHeaderFooterView {
        register(viewType, forHeaderFooterViewReuseIdentifier: String(describing: viewType))
    }

    func headerFooterView<View>(withType viewType: View.Type = View.self, withIdentifier reuseIdentifier: String? = nil) -> View
    where View: UITableViewHeaderFooterView {
        let reuseIdentifier = reuseIdentifier ?? String(describing: viewType)

        var view = dequeueReusableHeaderFooterView(withIdentifier: reuseIdentifier)

        if view == nil {
            register(viewType, forHeaderFooterViewReuseIdentifier: reuseIdentifier)
            view = dequeueReusableHeaderFooterView(withIdentifier: reuseIdentifier)
        }

        return view as! View // swiftlint:disable:this force_cast
    }

}

private class EmptyTableViewCell: UITableViewCell {

    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)

        backgroundColor = .clear
        selectionStyle = .none

        // height should be not 0, otherwise default height for cell (~44) will be used
        let view = UIView(frame: CGRect(x: 0, y: 0, width: 1, height: 1))
        view.backgroundColor = .clear
        contentView.addSubview(view)

        view.translatesAutoresizingMaskIntoConstraints = true
        // yes, true! using constraints from frame, don't want to create all constraints manually
        // and we only need to pin bottom
        view.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: 0).isActive = true
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
